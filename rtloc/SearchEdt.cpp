/*
 * @file SearchEdt.c grid search routines
 * 
 * Copyright (C) 2006-2007 Claudio Satriano <satriano@na.infn.it> and
 * Anthony Lomax <anthony@alomax.net>
 * This file is part of RTLoc.
 * 
 * RTLoc is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * RTLoc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with RTLoc; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */ 

#include "rtloclib.h"
extern float tnow;
extern float sigma;
extern int edt_null;

	#include "../global.h"

	#include "../config.h"

/** full normalization routine - Grid -> 0.0-1.0 */

void testFullNormalizationAJL(GridDesc *Grid) {

	int ix, iy, iz;

//luca
//	double val_max = -1.0e30;
//	double val_min = 1.0e30;
float val_max = -1.0e30f;
float val_min = 1.0e30f;

	int numx = Grid->numx;
	int numy = Grid->numy;
	int numz = Grid->numz;

	for (ix=0; ix<numx; ix++)
		for (iy=0; iy<numy; iy++)
			for (iz=0; iz<numz; iz++) {
				if (Grid->array[ix][iy][iz] > val_max)
					val_max = Grid->array[ix][iy][iz];
				if (Grid->array[ix][iy][iz] < val_min)
					val_min = Grid->array[ix][iy][iz];
			}

	for (ix=0; ix<numx; ix++)
		for (iy=0; iy<numy; iy++)
			for (iz=0; iz<numz; iz++) {
				Grid->array[ix][iy][iz] = Grid->array[ix][iy][iz] / val_max;
				//Grid->array[ix][iy][iz] = (Grid->array[ix][iy][iz] - val_min) / (val_max - val_min);
			}

	printlog(">>> testFullNormalizationAJL: val_min = %f val_max = %f\n", val_min, val_max);

}


/*
   SearchEdt: computes the edt map associated to the event evid (Grid[evid])
   and returns the maximum probability value over the grid, using all the
   picks associated to evid ("true" edt) and the stations not associated
   (conditional edt)
*/
//luca
//float SearchEdt (GridDesc *Grid, struct Pick *pick, struct Station *station, GridDesc *Pgrid, GridDesc *Sgrid, int evid, struct Control *params, int writeToDisk, int *imean)
float SearchEdt (GridDesc *Grid, struct Pick *pick, struct Station *station, int nsta_working, GridDesc *Pgrid, GridDesc *Sgrid, int evid, struct Control *params, int writeToDisk,	Vect3D *mean, Vect3D *ml_hypo, Mtrx3D *cov, Ellipsoid3D *ell, float *ml_otime)
{
	int ix, iy, iz;
	int numx, numy, numz;
	int nevaluated;

	double prob_max;
	double f_prob_max;

	char suffix[80];

	//double mean[3];
	//Vect3D mean={0.0,0.0,0.0};
	//double norm=0;

	//double ml_hypo[3]; //maximum likelihood hypocenter
//luca
//	Vect3D ml_hypo; //maximum likelihood hypocenter

//luca
//	if ( params->sum )
//		sprintf (Grid->chr_type, "RTLOC_SUM_%05.2f_%2.2f", tnow, sigma);
//	else
//		sprintf (Grid->chr_type, "RTLOC_MUL_%05.2f_%2.2f", tnow, sigma);


	//norm=mean[0]=mean[1]=mean[2]=0;
//luca
//	imean[0]=imean[1]=imean[2]=0;
	prob_max=0.0;
	f_prob_max = 0.0;

	/* Call to grid search algorithm */
	if (params->search_type == SEARCH_GRID) {
//luca
//		f_prob_max = GridSearch(Grid, pick, station, Pgrid, Sgrid, evid, params, &nevaluated, &prob_max, &ml_hypo);
f_prob_max = GridSearch(Grid, pick, station, nsta_working, Pgrid, Sgrid, evid, params, &nevaluated, &prob_max, ml_hypo);
	}
	else if (params->search_type == SEARCH_OCTTREE) {
//luca
//		f_prob_max = OctTreeSearch(Grid, pick, station, Pgrid, Sgrid, evid, params, &nevaluated, &prob_max, &ml_hypo);
f_prob_max = OctTreeSearch(Grid, pick, station, nsta_working, Pgrid, Sgrid, evid, params, &nevaluated, &prob_max, ml_hypo);
	}

	//printlog("prob_max = %f nevaluated = %d f_prob_max = %f\n", prob_max, nevaluated, f_prob_max);

//	imean[0] = (int) rint(mean.x);
//	imean[1] = (int) rint(mean.y);
//	imean[2] = (int) rint(mean.z);

	//printlog("(%4.2f) imean = (%d,%d,%d)\n", tnow, imean[0], imean[1], imean[2]);


	if ( params->renorm ) {
		numx = Grid->numx;
		numy = Grid->numy;
		numz = Grid->numz;
		for (ix=0; ix<numx; ix++)
		for (iy=0; iy<numy; iy++)
		for (iz=0; iz<numz; iz++) {
			Grid->array[ix][iy][iz] /= f_prob_max;
			if (Grid->array[ix][iy][iz] < params->pdfcut)
				Grid->array[ix][iy][iz] = 0;
		}
	}

// AJL - 20070116
//testFullNormalizationAJL(Grid);
// - AJL

//luca
LocStat (Grid, f_prob_max, Pgrid, Sgrid, mean, ml_hypo, station, evid, pick, params,	cov, ell, ml_otime);

//Write grid to disk
	if ( writeToDisk ) {
		sprintf (suffix, "ev%2.2d.%05.2f", evid, tnow);
//luca
//		WriteGrid3dBuf(Grid, NULL, params->outfilename, suffix);
//		fprintf (stderr, "Finished! Output basename: %s.%s\n", params->outfilename, suffix);
WriteGrid3dBuf(Grid, NULL, const_cast<char*>((sacs_dir + event_name).c_str()), suffix);

		// Print location statistics to a file
		// Moved into this block - CS 2008-07-28
//luca
//		LocStat (Grid, f_prob_max, Pgrid, Sgrid, &ml_hypo, station, evid, pick, params);
	}

	return f_prob_max;
}


/**
   Grid Search
 */
double GridSearch (GridDesc *Grid, struct Pick *pick, struct Station *station,
//luca
int nsta_working,
		   GridDesc *Pgrid, GridDesc *Sgrid, int evid,
		   struct Control *params, int *nevaluated,
		   double *prob_max, Vect3D *ml_hypo)
{
	int ix, iy, iz;
	int numx, numy, numz;

	int nsta;
	int npick;

	double prob;
	double f_prob_max = 0.0;
	double Pmax; //theoretical max probability density

	double xloc, yloc, zloc;

	int interpolate;
	double total_weight; //weighting factor for normalizing edt
	int ntriggered;	// AJL - 20070117

	interpolate = Grid->dx <= Pgrid->dx;	// may be too simple a test, check y, z ?

//luca
//	nsta = params->nsta;
nsta = nsta_working;
	npick = params->npick;

	numx = Grid->numx;
	numy = Grid->numy;
	numz = Grid->numz;

	xloc = Grid->origx;	// grid centered
	//xloc = Grid->origx + Grid->dx / 2.0;	// cell centered
	for (ix=0; ix<numx; ix++) {

		yloc = Grid->origy;	// grid centered
		//yloc = Grid->origy + Grid->dy / 2.0;	// cell centered
		for (iy=0; iy<numy; iy++) {

			zloc = Grid->origz;	// grid centered
			//zloc = Grid->origz + Grid->dz / 2.0;	// cell centered
			for (iz=0; iz<numz; iz++) {

				prob = calcEDTProb (pick, station, 
						    Pgrid, Sgrid, evid, xloc,
						    yloc, zloc, interpolate,
						    &ntriggered,
						    nevaluated, prob_max,
						    &total_weight, ml_hypo, params, &Pmax);

				/* Write the result to the output grid... */
				if (params->pow) {
			//Grid->array[ix][iy][iz] = exp(-nsta * (1.0 - normalize (prob, nevaluated)));
					Grid->array[ix][iy][iz] = pow (normalize (prob, *nevaluated), nsta);
					f_prob_max = pow (normalize (*prob_max, *nevaluated), nsta);
				}
				else {
					Grid->array[ix][iy][iz] = normalize (prob, *nevaluated);
					f_prob_max = normalize (*prob_max, *nevaluated);
				}

				zloc += Grid->dz;

			}

			yloc += Grid->dy;

		}

		xloc += Grid->dx;

	}	// end of loop over grid points

	return(f_prob_max);

}


/**
   Calculate EDT probability
 *
 *	interpolate - use interpolatation in reading time grid, otherwise,
 *		use time at largest grid node less than x,y,z (floor)
 *
 */
INLINE double calcEDTProb (struct Pick *pick, struct Station *station,
			   GridDesc *Pgrid, GridDesc *Sgrid, int evid,
			   double xloc, double yloc, double zloc,
			   int interpolate, int *ntriggered,
			   int *nevaluated, double *prob_max,
			   double *total_weight, Vect3D *ml_hypo,
			   struct Control *params, double *Pmax)
{

	int n, m;
	//int triggered;
	int statid;
	double weight;
	double ttA, ttB;
	double edt;
	double prob;
	//double normprob; //normalized probability

	int npick;
	int nsta;

	npick=params->npick;
	nsta=params->nsta;


	*Pmax = prob = (double) edt_null; //così dimentico tutto quello fatto agli step precedenti! forse posso cambiare

	*ntriggered = 0;	// AJL 20070117
	*nevaluated=0;
	*total_weight = 0.0;	// AJL 20070116 - weighting factor for normalizing edt

	// AJL 20070116 - Bug fix?  !!!Claudio: Is this now correct?
	//for (n=0; n<npick; n++) if (pick[n].evid == evid) {
	//	(*ntriggered)++;
	//}
	// - AJL

	/*First loop on associated picks, coupled with...*/
	for (n=0; n<npick; n++) if (pick[n].evid == evid) {
		// AJL 20070110
		//ttA = Read4dBuf (Ptt, ix, iy, numy, iz, numz, pick[n].statid, nsta);
		//ttA = ReadGrid3dValue (NULL, ix, iy, iz, &(Pgrid[pick[n].statid]));
		if (interpolate)
			ttA = ReadAbsInterpGrid3d(/*NULL,*/ &(Pgrid[pick[n].statid]), xloc, yloc, zloc);
		else
			ttA = ReadAbsGrid3dValue(/*NULL,*/ &(Pgrid[pick[n].statid]), xloc, yloc, zloc, 1);
		// -AJL
		//if (n == 0)	// AJL 20070116 - Bug fix?  !!!Claudio: Is this now correct?
			*ntriggered = 1;

		/*...a second loop on associated picks...*/
#if 1
		for (m=n; m<npick; m++) if (pick[m].evid == evid) {
			// AJL 20070110
			//ttB = Read4dBuf (Ptt, ix, iy, numy, iz, numz, pick[m].statid, nsta);
			//ttB = ReadGrid3dValue (NULL, ix, iy, iz, &(Pgrid[pick[m].statid]));
			if (interpolate)
				ttB = ReadAbsInterpGrid3d(/*NULL,*/ &(Pgrid[pick[m].statid]), xloc, yloc, zloc);
			else
				ttB = ReadAbsGrid3dValue(/*NULL,*/ &(Pgrid[pick[m].statid]), xloc, yloc, zloc, 1);
			// -AJL
			edt = do_edt (ttA, ttB, pick[n].time, pick[m].time);
			(*nevaluated)++;
			*total_weight += 1.0;	// AJL 20070116
			//if (n == 0)	// AJL 20070116 - Bug fix?  !!!Claudio: Is this now correct?
			(*ntriggered)++;

			if ( params->sum ) {
				prob += edt;
				*Pmax += 1;
			}
			else {
				prob *= edt;
				*Pmax *= 1;
				if (!prob) break; // The system of equations is not fulfilled
			}
			if ( prob > *prob_max ) {
				*prob_max = prob;
				ml_hypo->x = xloc;
				ml_hypo->y = yloc;
				ml_hypo->z = zloc;
			}
		}
#endif

//luca (paramater to use or ignore non triggering stations)
//#if USE_NOT_YET_TRIGGERED==1
if (param_locate_use_non_triggering_stations)
{
		/*...and/or a loop over not associated stations*/
//luca use -1,0,1 meaning ignore (e.g. data communication problems),not associated, associated
//		for (statid=0; statid<nsta; statid++) if (station[statid].evid[evid] != 1) {
for (statid=0; statid<nsta; statid++) if (station[statid].evid[evid] == 0) {
			// AJL 20070110
			//ttB = Read4dBuf (Ptt, ix, iy, numy, iz, numz, statid, nsta);
			//ttB = ReadGrid3dValue (NULL, ix, iy, iz, &(Pgrid[statid]));
			if (interpolate)
				ttB = ReadAbsInterpGrid3d(/*NULL,*/ &(Pgrid[statid]), xloc, yloc, zloc);
			else
				ttB = ReadAbsGrid3dValue(/*NULL,*/ &(Pgrid[statid]),  xloc, yloc, zloc, 1);
			// -AJL
			edt = do_edt (ttA, ttB, pick[n].time, 10000);
			(*nevaluated)++;

			weight = 1.0;
			if ( *ntriggered >= 3 ) //was 3 c.s.
//luca
//				weight = exp (-(*ntriggered - 3));
weight = exp (-double(*ntriggered - 3));
			*total_weight += weight;	// AJL 20070116

			if ( params->sum ) {
				prob += weight * edt;
				*Pmax += weight;
			}
			else {
				prob *= edt;
				*Pmax *= 1;
				if (!prob) break; // The system of equations is not fulfilled
			}
			if ( prob > *prob_max ) {
				*prob_max = prob;
				ml_hypo->x = xloc;
				ml_hypo->y = yloc;
				ml_hypo->z = zloc;
			}
		}
// luca
//#endif
}


	}	//end of first loop on associated picks

	*ntriggered=1;
	for (n=0; n<npick; n++) if (pick[n].evid == evid) {
		(*ntriggered)++;
	}


	return(prob);

}

